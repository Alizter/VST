(** * Relating axiomatic SC semantics to the Erased machine (operational SC) *)

Require Import concurrency.Machine_ax.
Require Import concurrency.Executions_ax.
Require Import Coq.Sets.Ensembles.
Require Import Coq.Relations.Relations.
Require Import concurrency.Ensembles_util.
Require Import concurrency.Relations_util.

(** This proof is done in two steps:
    1. Valid SC executions ([validSC]) generated by the axiomatic semantics
       [step_po] are related to valid SC executions generated by an intermediate
       axiomatic semantics that follow the [sc] order instead.
    2. The intermediate axiomatic semantics are related to the operational
       SC semantics. *)

(** * Part 1 *)
Module AxiomaticIntermediate.

  Import Execution.
  Import ValidSC.
  Import AxSem.
  Import Order Enumerate PropExtSets.

  (** Assume excluded middle *)
  Axiom EM : ClassicalFacts.excluded_middle.
  
  Section AxiomaticIntermediate.
    Context
      {lbl : Labels}
      {sem : Semantics}
      {threadpool : ThreadPool C}
      {genv : G}
      {exec : Execution}
      {po sc : relation id}.

    Variable cstep: G -> C ->  C -> list E -> Prop.

    Notation " '[' tp1 , Ex1 ']'   '==>{' n  '}'  '[' tp2 , Ex2 ']' " :=
      (stepN (Rstep cstep genv po sc) n tp1 Ex1 tp2 Ex2) (at level 40).

    Notation " '[' tp1 , Ex1 ']'  '==>po' '[' tp2 , Ex2 ']' " :=
      (step_po cstep genv po tp1 Ex1 tp2 Ex2) (at level 40).

    Notation " '[' tp1 , Ex1 ']'  '==>sc' '[' tp2 , Ex2 ']' " :=
      (Rstep cstep genv po sc tp1 Ex1 tp2 Ex2) (at level 40).

    Notation "tp1 '[' i , ls ']==>' tp2" :=
      (AxSem.step cstep genv tp1 i ls tp2) (at level 40).

    (** Simulation Relation between [tp1, Ex1] and [tp2, Ex2] indexed by a nat n (number of steps)
        and a set of events Ex. *)
    Record sim (n:nat) (Ex : events) (tp1 : t) (Ex1 : events) (tp2 : t) (Ex2 : events) :=
      { set_dis  : Disjoint _ Ex1 Ex2; (** Ex1 and Ex2 are [Disjoint] *)
        set_inv  : Ex <--> Union _ Ex1 Ex2; (** Ex is the [Union] of Ex1 and Ex2 *)
        sc_steps : [tp2, Ex2] ==>{n} [tp1, Empty_set _]; (** [tp2, Ex2] reaches tp1 after n sc-steps *)
        ex_po    : forall e2, e2 \in Ex2 ->
                               forall e1, e1 \in Ex1 ->
                                            ~ po e1 e2; (** No event \in Ex1 is po-before any event in e2*)
        sc_tot   : strict_total_order sc Ex;
        po_wf    : po_well_formed po;
        po_sc    : inclusion _ po sc
      }.

    Import PeanoNat.Nat.

    (** ** Basic Properties of valid executions *)

    (** Two events not in [po] must be from different threads *)
    Lemma no_po_thread_neq:
      forall e e'
        (Hneq: e <> e')
        (HpoWF: po_well_formed po)
        (Hpo1: ~ po e e')
        (Hpo2: ~ po e' e),
        thread e <> thread e'.
    Proof.
      intros.
      destruct (eq_dec (thread e) (thread e')) as [Htid_eq | Htid_neq];
        [destruct (po_same_thread _ HpoWF _ _ Htid_eq);
         now auto | assumption].
    Qed.

    (** Two events not in [po] cannot be related by a Spawn operation *)
    Lemma no_po_spawn_neq:
      forall e e' es
        (Hneq: e <> e')
        (HpoWF: po_well_formed po)
        (Hpo1: ~ po e e')
        (Hpo2: ~ po e' e)
        (Henum: forall e'', List.In e'' es -> po e e''),
        ~ List.In (Spawn (thread e')) (List.map lab (e :: es)).
    Proof.
      intros.
      intros Hcontra.
      (** Since there was a [Spawn (thread e')] event in the trace (say e''),
              it is the case that (e'', e') \in po and (e, e'') \in po? *)
      assert (He'': lab e = Spawn (thread e') \/
                    exists e'', List.In e'' es /\ lab e'' = Spawn (thread e')).
      { clear - Hcontra.
        simpl in Hcontra.
        destruct Hcontra.
        eauto.
        right.
        apply List.in_map_iff in H.
        destruct H as [? [? ?]]; eexists; eauto.
      }
      destruct He'' as [? | [e'' [HIn Heq]]]; [destruct HpoWF; now eauto|].
      pose proof (po_spawn _ HpoWF _ _ Heq).
      specialize (Henum _ HIn).
      apply Hpo1.
      eapply trans;
        now eauto with Relations_db Po_db.
    Qed.

    (** The thread pool is invariant with respect to the thread of event e' when
            thread of event e steps and the two events are not in [po]. *)
    Lemma no_po_gsoThread:
      forall e e' es tp tp'
        (Hneq: e <> e')
        (HpoWF: po_well_formed po)
        (Hpo1: ~ po e e')
        (Hpo2: ~ po e' e)
        (Henum: forall e'', List.In e'' es -> po e e'') 
        (Hstep: tp [thread e, List.map lab (e :: es) ]==> tp'),
        getThread (thread e') tp' = getThread (thread e') tp.
    Proof.
      intros.
      assert (Htid_neq: thread e <> thread e')
        by (eapply no_po_thread_neq; eauto).
      inv Hstep;
        try (erewrite gsoThread; now eauto).
      (** Spawn thread case*)
      erewrite! gsoThread; eauto.
      intros Hcontra; subst.
      eapply no_po_spawn_neq with (e' := e') (e := e);
        eauto.
      simpl (List.map lab (e :: es)).
      rewrite <- H0.
      apply List.in_or_app;
        simpl; now eauto.
    Qed.

    (** ** Basic Properties of program semantics *)
    Lemma step_gsoThread:
      forall e e' es tp tp'
        (Hneq: thread e <> thread e')
        (Hspawn:  ~ List.In (Spawn (thread e')) (List.map lab (e :: es)))
        (Hstep: tp [thread e, List.map lab (e :: es) ]==> tp'),
        getThread (thread e') tp' = getThread (thread e') tp.
    Proof.
      intros.
      inv Hstep;
        try (erewrite gsoThread; now eauto).
      (** Spawn thread case*)
      erewrite! gsoThread; eauto.
      intros Hcontra; subst.
      apply Hspawn.
      simpl (List.map lab (e :: es)).
      rewrite <- H0.
      apply List.in_or_app;
        simpl; now eauto.
    Qed.

    (** [step] is invariant to [updThread] when the thread updated is
        not the stepping thread or a thread spawned by the stepping thread *)
    Lemma step_updThread:
      forall tp i es tp' j c'
        (Hneq: i <> j)
        (Hspawn: ~List.In (Spawn j) es)
        (Hstep: tp [i, es]==> tp'),
        updThread j c' tp [i, es]==>
                  updThread j c' tp'.
    Proof.
      intros.
      inv Hstep.
      - simpl.
        erewrite updComm by eauto.
        econstructor; eauto.
        erewrite gsoThread by eauto.
        assumption.
      - simpl.
        erewrite updComm by eauto.
        econstructor 2; eauto.
        erewrite gsoThread by eauto;
          eassumption.
      - simpl.
        assert (j <> j0).
        { intros Hcontra.
          subst.
          clear - Hspawn.
          apply Hspawn; auto.
          eapply List.in_or_app; simpl;
            now eauto.
        }
        assert (j0 <> i)
          by (intros Hcontra;
              subst; congruence).
        assert (Hupd: updThread j0 c'' (updThread i c'0 tp) =
                      updThread i c'0 (updThread j0 c'' tp))
          by (erewrite updComm; eauto).
        rewrite Hupd.
        erewrite updComm by eauto.
        assert (Hupd': updThread j c' (updThread j0 c'' tp) =
                       updThread j0 c'' (updThread j c' tp))
          by (erewrite updComm; eauto).
        rewrite Hupd'.
        erewrite updComm by eauto.
        econstructor 3; eauto.
        erewrite gsoThread by eauto;
          eassumption.
        erewrite gsoThread by eauto;
          assumption.
    Qed.

    (** Spawned thread not in threadpool before spawning, but in threadpool after spawning *)
    Lemma step_spawn:
      forall tp tp' es i j
        (Hstep: tp [i, es]==> tp')
        (Hspawn: List.In (Spawn j) es),
        getThread j tp = None /\
        getThread j tp' <> None.
    Proof.
      intros.
      inv Hstep;
        try (exfalso; eapply concLabelsofE_no_spawn; now eauto).
      assert (j = j0).
      { clear - Hspawn.
        eapply List.in_app_or in Hspawn.
        destruct Hspawn as [?| HIn];
          [exfalso; eapply concLabelsofE_no_spawn;
           now eauto|].
        simpl in HIn.
        destruct HIn as [HIn | HIn];
          now inv HIn.
      }
      subst.
      split;
        [now auto| rewrite gssThread; now congruence].
    Qed.

    Lemma getThread_monotone:
      forall tp j c i es tp'
        (Hget: getThread j tp = Some c)
        (Hstep: tp [i, es]==> tp'),
      exists c',
        getThread j tp' = Some c'.
    Proof.
      intros.
      destruct (eq_dec i j).
      - subst.
        inv Hstep;
          try (eexists; erewrite gssThread;
               now eauto).
        destruct (eq_dec j j0); subst; [congruence|].
        eexists; erewrite gsoThread by eauto.
        erewrite gssThread; eauto.
      - inv Hstep;
          try (erewrite gsoThread by eauto; eauto).
        destruct (eq_dec j j0); subst; [congruence|].
        erewrite! gsoThread;
          now eauto.
    Qed.

    (** * Properties of combined program/execution steps *)

    (** Commuting steps *)
    Lemma commute_step_sc:
      forall tp Ex Ex' tp' es e' es' tp''
        (** If [tp, Ex] takes an sc-step to [tp', Ex'] *)
        (HstepSC: [tp, Ex] ==>sc [tp', Ex'])

        (** and tp' can step to tp'' with events [e' :: es'] *)
        (Hstep: tp' [thread e', List.map lab (e' :: es')]==> tp'')

        (** and if the set of events [e' :: es'] is disjoint from Ex *)
        (Henum: enumerate po es (e' :: es')%list)
        (Hdisjoint: Disjoint _ es Ex)

        (** and the minimal element in (e' :: es')
            is sc-before any event in Ex (and hence no event in Ex is po-before e')*)
        (HminSC: forall e, e \in Ex -> sc e' e)

        (** and also e' is not po-before any event in Ex *)
        (Hpo: forall e, e \in Ex -> ~ po e' e)
        (HpoWF: po_well_formed po)
        (HscPO: strict_partial_order sc)
        (Hposc: inclusion _ po sc),

        (** then the two steps are ``independent`` and can be reordered *)
      exists tp0,
        [tp, Union _ Ex es] ==>sc [tp0, Ex] /\
        [tp0, Ex] ==>sc [tp'', Ex'].
    Proof.
      intros.
      inv HstepSC.

      (** *** Useful facts in the proof *)
      assert (HIn0: In _ es0 e'0)
        by (destruct Henum0; eapply H; simpl; now auto).

      (** e'0 <> e' *)
      assert (Hneq_ev: e'0 <> e').
      { intros Hcontra; subst.
        apply Disjoint_sym in Hdisjoint.
        apply Disjoint_Union_r in Hdisjoint.
        inversion Hdisjoint as [Hdisjoint'].
        specialize (Hdisjoint' e').
        apply Hdisjoint'.
        pose proof (proj2 (proj1 Henum e') ltac:(simpl; auto)).
        pose proof (proj2 (proj1 Henum0 e') ltac:(simpl; auto)).
        eauto with Ensembles_DB.
      }

      (** ~ po e'0 e *)
      assert (Hnot_po1: ~po e'0 e').
      { specialize (HminSC e'0 ltac:(eauto with Ensembles_DB)).
        intros Hcontra.
        apply Hposc in Hcontra.
        pose proof (antisym _ HscPO _ _ Hcontra HminSC).
        subst.
        eapply (strict _ HscPO);
          now eauto.
      }

      (** Every element in es'0 is po-after e'0 by the spec of [enumerate]*)
      assert (Henum_spec: forall e'' : id, List.In e'' es'0 -> po e'0 e'')
        by (intros;
            eapply @enumerate_spec with (es := es0) (es' := nil);
            simpl; eauto with Po_db Relations_db).

      (** The state of (thread e') is unchanged by the step of (thread e'0) *)
      assert (Hget_e': getThread (thread e') tp'= getThread (thread e') tp)
        by (eapply no_po_gsoThread with (e := e'0) (e' := e'); eauto).
  
      (** *** First prove commutativity for program steps *)
      assert (Hprog_step: exists tp0, tp [thread e', List.map lab (e' :: es')]==> tp0 /\
                                 tp0 [thread e'0, List.map lab (e'0 :: es'0)]==> tp'').
      { inv Hstep.
        - exists (updThread (thread e') c' tp).
          split.
          + simpl. rewrite <- H0.
            econstructor; eauto.
            rewrite <- Hget_e'.
            assumption.
          + simpl.
            apply step_updThread;
              eauto using no_po_thread_neq, no_po_spawn_neq.
        - exists (updThread (thread e') c' tp).
          split.
          + simpl. rewrite <- H0.
            econstructor 2; eauto.
            rewrite <- Hget_e'.
            assumption.
          + simpl.
            apply step_updThread;
              eauto using no_po_thread_neq, no_po_spawn_neq.
        - exists (updThread j c'' (updThread (thread e') c' tp)).
          (** proof that j was not a valid thread at tp *)
          assert (Hget_j': getThread j tp = None).
          { destruct (getThread j tp) eqn:Hgetj; auto.
            destruct (getThread_monotone tp j _ _ _ tp' Hgetj Hstep0) as [? ?];
              now congruence.
          }
          split.
          + simpl. rewrite <- H0.
            econstructor 3; eauto.
            rewrite <- Hget_e'.
            assumption.
          + simpl.
            (** [thread e'0] <> j because getThread (thread e'0) tp = Some _ by the fact
                that it steps and getThread j tp = None as proved *)            
            assert (thread e'0 <> j)
              by (intros ?; subst; inv Hstep0; now congruence).
            (** Moreover, it cannot be that the step from [thread e'0] has an event [Spawn j]
                because that would imply that it spawned thread j but we know that
                getThread j tp' = None which leads to a contradiction *)
            assert (~ List.In (Spawn j) (lab e'0 :: List.map lab es'0)).
            { intros Hcontra.
              eapply step_spawn in Hcontra; eauto.
              destruct Hcontra;
                congruence.
            }
            (** Now we can use the fact that the update of the threadpool on
                thread j does not affect the step of thread e'0 *)
            eapply step_updThread;
              eauto using no_po_thread_neq, no_po_spawn_neq.
            (** Likewise for the step of thread e' *)
            eapply step_updThread;
              eauto using no_po_thread_neq, no_po_spawn_neq.
      }
      destruct Hprog_step as [tp0 [Hprog_stepe' Hprog_step0']].
      exists tp0.
      (** To prove that there is an sc step we also need to prove that
          the events used by the program steps are sc-minimal in the execution *)
      assert (Hmin_e': In _ (Order.min sc (Union _ (Union _ Ex' es0) es)) e').
      {
        (** We know by the fact that e' is in the head of the enumeration of es
        it is the po-minimal element in es, and hence it must also be sc-minimal
        in es as po is included in sc *) 
        assert (Hmin_1: In _ (Order.min sc es) e').
        { constructor.
          eapply Henum;
            now (simpl; auto).
          intros (y & Hy & Hcontra).
          eapply Henum in Hy.
          simpl in Hy.
          destruct Hy as [Hy | Hy];
            [subst; eapply strict;
             now eauto with Relations_db|].
          eapply enumerate_hd in Henum; eauto with Relations_db Po_db.
          apply Hincl in Henum.
          pose proof (antisym _ ltac:(eauto) _ _ Hcontra Henum);
            subst.
          eapply strict;
            now eauto.
        }
        econstructor.
        constructor 2.
        eapply Henum; simpl;
          now eauto.
        intros (emin & HIn & Hcontra).
        eapply In_Union_inv in HIn.
        destruct HIn as [HIn | HIn].
        - (** Case emin is in Union Ex' es0 *)
          (** We know that every element of Union Ex' es0 is sc-smaller than e
            by HminSC *)
          specialize (HminSC _ HIn).
          pose proof (antisym _ ltac:(eauto) _ _ Hcontra HminSC);
            subst.
          eapply strict;
            eauto with Relations_db Po_db.
        - (** Case emin is in es *)
          (** By the fact we just proved (Hmin_1) that e' is sc-minimal in es *)
          inversion Hmin_1 as [_ Hmin_contra].
          apply Hmin_contra.
          eexists; split;
            now eauto.
      }
      split;
        econstructor;
        now eauto with Ensembles_DB.
    Qed.

    Lemma commute_steps_sc:
      forall n tp Ex Ex' tp' es e' es' tp''
        (HstepSC: [tp, Ex] ==>{n} [tp', Ex'])
        (Hstep: tp' [thread e', List.map lab (e' :: es')]==> tp'')
        (Henum: enumerate po es (e' :: es')%list)
        (Hdisjoint: Disjoint _ es Ex)
        (HminSC: forall e, e \in Ex -> sc e' e)
        (Hpo: forall e, e \in Ex -> ~ po e' e)
        (HpoWF: po_well_formed po)
        (HscPO: strict_partial_order sc)
        (Hposc: inclusion _ po sc),
      exists tp0,
        [tp, Union _ Ex es] ==>sc [tp0, Ex] /\
        [tp0, Ex] ==>{n} [tp'', Ex'].
    Proof.
      intros.
      generalize dependent tp.
      generalize dependent Ex.
      induction n; intros.
      - (** Base case *)
        inv HstepSC.
        exists tp''.
        split; eauto using Step0.
        econstructor;
          eauto with Ensembles_DB.
        constructor.
        constructor 2.
        eapply Henum;
          simpl; now auto.
        intros (y & HIn & Hsc).
        eapply In_Union_inv in HIn.
        destruct HIn as [HIn | HIn].
        + specialize (HminSC _ HIn).
          pose proof (antisym _ ltac:(eauto) _ _ Hsc HminSC);
            subst.
          eapply strict;
            eauto with Relations_db Po_db.
        + eapply Henum in HIn.
          simpl in HIn.
          destruct HIn as [HIn | HIn];
            [subst; eapply strict;
             now eauto with Relations_db|].
          eapply enumerate_hd in Henum; eauto with Relations_db Po_db.
          apply Hposc in Henum.
          pose proof (antisym _ ltac:(eauto) _ _ Hsc Henum);
            subst.
          eapply strict;
            now eauto.
      - (** Inductive Case *)
        inversion HstepSC as [|? ? ? tp0 Ex0 ? ? ?]; subst.
        clear HstepSC.
        assert (Hdisjoint0: Disjoint id es Ex0)
          by (inv HRstep; eauto with Ensembles_DB).
        assert (HminSC0: forall e, In id Ex0 e -> sc e' e)
          by (inv HRstep; eauto with Ensembles_DB).
        assert (Hpo0: forall e, In _ Ex0 e -> ~ po e' e)
          by (inv HRstep; eauto with Ensembles_DB).
        (** By inductive hypothesis*)
        destruct (IHn _ Hdisjoint0 HminSC0 Hpo0 _ HRstepN') as [tp1 [Hstep1 HRstepN'']].
        clear HRstepN'.
        (** and by applying the commutativity lemma *)
        inversion Hstep1; subst.
        (** proof that the sets es0 and es are the same *)
        eapply Disjoint_Union_eq in H0; eauto with Ensembles_DB.
        eapply same_set_eq in H0; subst; eauto.
        (** and hence their enumerations as well *)
        pose proof (enumerate_ext _ _ _ eq_dec (po_strict_PO _ HpoWF) Henum Henum0) as Heq;
          inv Heq.
        assert (Hstep_comm: exists tp2, [tp, Union _ Ex es] ==>sc [tp2, Ex] /\
                                   [tp2, Ex] ==>sc [tp1, Ex0])
          by (eapply commute_step_sc;
              now eauto).
        destruct Hstep_comm as [tp2 [Hstep_tp Hstep_tp2]].
        exists tp2.
        split;
          [now auto | econstructor; now eauto].
    Qed.
    
    Lemma stepN_commute_stepSN:
      forall n tp Ex es e' es' tp' Ex' tp''
        (Hsc_steps: [tp, Ex] ==>{n} [tp', Ex'])
        (Hp_step: tp' [thread e', List.map lab (e' :: es')]==> tp'')
        (Henum: enumerate po es (e' :: es'))
        (HminSC: forall e, e \in Ex -> sc e' e)
        (Hpo: forall e, e \in Ex -> ~ po e' e)
        (HpoWF: po_well_formed po)
        (HscPO: strict_partial_order sc)
        (Hincl: inclusion _ po sc)
        (Hdis: Disjoint _ Ex es),
        [tp, Union _ Ex es] ==>{S n} [tp'', Ex'].
    Proof.
      intros.
      eapply commute_steps_sc in Hsc_steps; eauto with Ensembles_DB.
      destruct Hsc_steps as [tp0 [Hstep_sc0 Hsteps_sc0]].
      econstructor;
        now eauto.
    Qed.

    (** After stepping, the initial execution is a superset of the
        resulting execution *)
    Lemma stepN_union_inv:
      forall n tp tp' Ex es Ex'
        (HstepN: [tp, Ex] ==>{n} [tp', Union _ Ex' es]),
      exists Ex0, Ex = Union _ (Union _ Ex0 Ex') es.
    Proof.
      intro n.
      induction n; intros.
      - inversion HstepN; subst.
        exists (Empty_set _).
        apply same_set_eq.
        rewrite Union_commut with (s1 := (Empty_set id)).
        rewrite Union_empty_set_id;
          now eauto with Ensembles_DB.
      - inv HstepN.
        destruct (IHn _ _ _ _ _ HRstepN') as [Ex0 ?];
          subst.
        inv HRstep.
        exists (Union _ Ex0 es0).
        apply same_set_eq.
        rewrite <- Union_assoc.
        rewrite <- Union_assoc.
        rewrite Union_commut with (s1 := es).
        rewrite Union_assoc with (s1 := Ex') (s2 := es0).
        rewrite Union_commut with (s1 := Ex').
        rewrite Union_assoc.
        eauto with Ensembles_DB.
    Qed.

    (*TODO: redo this proof, by inversion? *)
    (** If a subset of an execution remains unchanged then its elements cannot be sc-minimal *)
    Lemma stepN_inv_not_minimal:
      forall n tp Ex Ex' es tp' e esl
        (HstepN: [tp, Union _ Ex es] ==>{S n} [tp', Union _ Ex' es])
        (Henum: enumerate po es (e :: esl))
        (HscTO: forall e1 e2, e1 <> e2 -> e1 \in (Union _ Ex es) /\
                                          e2 \in (Union _ Ex es) ->
                                                 sc e1 e2 \/ sc e2 e1),
        ~ e \in Order.min sc (Union _ Ex es).
    Proof.
      intro n.
      destruct n; intros.
      - inversion HstepN as [|? ? tp2 Ex2 ? ?]; subst.
        inv HRstepN'.
        intros HIn.
        destruct HIn as [HIn  Hmin].
        inversion HRstep; subst.
        inv Hmin0.
        apply H1.
        exists e.
        split;
          [rewrite H0; now eauto|].
        assert (Hneq: e <> e').
        { intros ?; subst.
          pose proof (proj2 (proj1 Henum e' ) ltac:(simpl; auto)).
          pose proof (proj2 (proj1 Henum0 e') ltac:(simpl; auto)).
          eapply Hdis with (x := e').
          now eauto with Ensembles_DB.
        }
        destruct (HscTO e e' Hneq); auto.
        split;
          [|rewrite <- H0]; eauto with Ensembles_DB.
        exfalso.
        apply Hmin.
        exists e'.
        rewrite <- H0.
        split;
          now eauto with Ensembles_DB.
      - inv HstepN.
        inv HRstep.
        destruct (stepN_union_inv _ _ _ _ _ _ HRstepN') as [Ex0 Heq];
          subst.
        assert (Hneq: e <> e').
        { intros ?; subst.
          pose proof (proj2 (proj1 Henum e' ) ltac:(simpl; auto)).
          pose proof (proj2 (proj1 Henum0 e') ltac:(simpl; auto)).
          eapply Hdis with (x := e').
          now eauto with Ensembles_DB.
        }
        destruct (HscTO e e' Hneq) as [Hsc | Hsc]; auto.
        + split;
            [right; eapply Henum; simpl; now auto|].
          rewrite H0 in Hmin;
            now eapply Hmin.
        + intros _.
          eapply Hmin.
          exists e.
          split; [left; right | assumption].
          eapply Henum;
            simpl; now auto.
        + intros Hcontra.
          destruct Hcontra as [? Hcontra].
          apply Hcontra.
          exists e'.
          split; [right| assumption].
          eapply Henum0;
            simpl; now auto.
    Qed.

    (** Given an event e an sc-execution of n steps can be split to two executions
          of k and l steps s.t all events of the k execution are sc-before than e
          and all events of the l execution are sc-after e *)
    Lemma steps_sc_split_at:
      forall n tp1 Ex1 tp1' tp1'' e es esl
        (HstepsN: [tp1, Ex1] ==>{n} [tp1', Empty_set _])
        (Hincl: inclusion _ po sc)
        (Hstep: tp1' [thread e, List.map lab (e :: esl)]==> tp1'')
        (Henum: enumerate po es (e :: esl)%list)
        (Hfresh: Disjoint _ Ex1 es)
        (Hpo: forall e', e' \in Ex1 -> ~ po e e')
        (HpoWF: po_well_formed po)
        (HscPO: strict_partial_order sc)
        (HscTO: forall e1 e2, e1 <> e2 -> e1 \in (Union _ Ex1 es) /\ e2 \in (Union _ Ex1 es) ->
                                                                    sc e1 e2 \/ sc e2 e1),
      exists Ex0' Ex0 tp0 tp0' k l,
        Ex1 = Union _ Ex0 Ex0' /\ Disjoint _ Ex0 Ex0' /\
        [tp1, Union _ (Union _ Ex0 Ex0') es] ==>{k} [tp0, Union _ Ex0 es] /\
        [tp0, Union _ Ex0 es] ==>sc [tp0', Ex0] /\
        [tp0', Ex0] ==>{l} [tp1'', Empty_set _] /\
        (n = k + l).
    Proof.
      intro n.
      induction n; intros.
      - inv HstepsN.
        (** If n = 0 then k and l will be 0 and we only have the extra step to do *)
        exists (Empty_set _), (Empty_set _), tp1', tp1'', 0, 0.
        assert (HeqEmpty: Empty_set _ = Union id (Empty_set _) (Empty_set _))
          by (eapply same_set_eq; eauto with Ensembles_DB).
        rewrite <- HeqEmpty.
        repeat (split; eauto using Step0 with Ensembles_DB).
        econstructor; eauto.
        (** e is sc-min in es *)
        constructor.
        + (** 1. e \in es *)
          right.
          eapply Henum; simpl;
            now auto.
        + (** 2. no y \in es s.t. sc y e *)
          intros (y & Hiny & Hcontra).
          apply In_Union_inv in Hiny.
          destruct Hiny as [HcontraIn | Hiny]; [inv HcontraIn|].
          eapply Henum in Hiny.
          simpl in Hiny; destruct Hiny as [? | HIny];
            subst.
          eapply strict; eauto.
          eapply @enumerate_spec with (R := po) (e:= e) (es' := nil) in HIny;
            eauto with Po_db Relations_db.
          apply Hincl in HIny.
          pose proof (antisym _ HscPO _ _ Hcontra HIny); subst.
          eapply strict;
            now eauto.
      - inversion HstepsN as [|? ? ? tp2 Ex2 ? ? ? ?];
          subst.
        (** Establish the premises of the IH *)
        assert (Hfresh2: Disjoint _ Ex2 es)
          by (inv HRstep; eauto with Ensembles_DB).
        assert (Hpo2: forall e', In _ Ex2 e' -> ~po e e')
          by (inv HRstep;
              eauto with Ensembles_DB).
        assert (HscTO2: forall e1 e2, e1 <> e2 -> e1 \in (Union _ Ex2 es) /\ e2 \in (Union _ Ex2 es) ->
                                                                            sc e1 e2 \/ sc e2 e1).
        { intros e1 e2 Hneq (HIn1 & HIn2).
          inv HRstep.
          eapply HscTO; auto;
            try (split; [inv HIn1 | inv HIn2];
                 now eauto with Ensembles_DB).
        }
        destruct (IHn _ _ _ _ _ _ _ HRstepN' Hincl Hstep Henum Hfresh2 Hpo2 HpoWF HscPO HscTO2) as
            (Ex0' & Ex0 & tp0 & tp0' & k & l & HEx1 & HDisjointEx1 & HRstepK & HRstep0 & HRstepL & Hkl);
          clear IHn.
        (** We have split the n-step execution [tp2, Ex2] ==>{n} [tp1', Empty_set].
              We now need to add the [tp1, Ex1] ==>sc [tp2, Ex2] to this execution and we have the following cases:
              - If k = 0 then [tp1, Ex1] ==> [tp2, Ex2] is adjacent in the trace to [tp0, Union Ex0 es] ==> [tp0', Ex0].
                Depending on which one is sc-before we may need to commute these two steps.
              - If k > 0 then by the fact that [tp2, Union Ex2 es] =>{k} [tp0, Union Ex2' es] it must be
                that es is not minimal in Union Ex2 es and hence es0 is sc-before es.*)
        destruct k.
        + (** Case k = 0 *)
          inversion HRstepK as [? ? H0' H1' H2' H3' HeqSets|];
            subst; clear H0'.
          assert (HEx0': Ex0' = Empty_set _).
          { assert (Heq': Union _ (Union _ Ex0 Ex0') es <--> Union id Ex0 es)
              by (rewrite HeqSets; eauto with Ensembles_DB).
            setoid_rewrite <- Union_assoc in Heq'.
            apply same_set_eq in Heq'.
            eapply Disjoint_Union_eq in Heq'; eauto with Ensembles_DB.
            rewrite <- Union_empty_set_id in Heq'.
            rewrite Union_commut in Heq'.
            eapply same_set_eq in Heq'.
            eapply Disjoint_Union_eq in Heq'; eauto with Ensembles_DB.
            now apply same_set_eq.
          }
          pose proof HRstep as HRstep_copy.
          inv HRstep.
          (** Case analysis on whether sc e e' or sc e' e *)
          assert (Hneq: e <> e').
          { intros Hcontra; subst.
            eapply Hfresh with (x := e').
            inv Hmin.
            constructor; eauto with Ensembles_DB.
            eapply Henum; simpl;
              now auto.
          }
          assert (HIn: In id (Union id (Union id (Union id Ex0 (Empty_set _)) es0) es) e /\
                       In id (Union id (Union id (Union id Ex0 (Empty_set _)) es0) es) e').
          { split.
            right. eapply Henum; simpl; now auto.
            left. right. eapply Henum0; simpl; now auto.
          }
          destruct (HscTO _ _ Hneq HIn) as [Hsc | Hsc]; clear HIn.
          * (** Case sc e e' *)
            (** In this case, the first step to happen is the one of es, hence k will be zero *)
            assert (Hcommut: exists tp00,
                       [tp1, Union _ (Union _ Ex0 es0) es] ==>sc [tp00, Union _ Ex0 es0] /\
                       [tp00, Union _ Ex0 es0] ==>sc [tp0', Ex0]).
            { rewrite Union_empty_set_id in HRstep_copy.
              inv HRstep0.
              assert (es = es1).
              { apply Disjoint_Union_eq in H0; eauto with Ensembles_DB.
                now apply same_set_eq.
              }
              subst.
              pose proof (enumerate_ext _ _ _ eq_dec (po_strict_PO _ HpoWF) Henum Henum1) as Heq;
                inv Heq.
              eapply commute_step_sc with (tp := tp1) (tp'' := tp0')
                                                      (es := es1);
                eauto.
              - eapply Disjoint_Union_r in Hfresh;
                  now eauto with Ensembles_DB.
              - intros x HIn.
                eapply In_Union_inv in HIn.
                assert (Hneqx: x <> e'0).
                { intros Hcontra; subst.
                  pose proof (proj2 (proj1 Henum1 e'0) ltac:(simpl; now auto)).
                  destruct HIn.
                  eapply Hdis0;
                    now eauto with Ensembles_DB.
                  eapply Disjoint_Union_r in Hfresh.
                  eapply Hfresh;
                    now eauto with Ensembles_DB.
                }
                destruct (HscTO x e'0 Hneqx) as [Hscx | Hscx].
                (** leftover goal from destructing HscTO *)
                split; [destruct HIn as [HIn | HIn];
                        eauto with Ensembles_DB |
                        destruct Henum1 as [HIne'0 _]; right;
                        eapply HIne'0; simpl; now auto].
                + (** Case sc x e'0 *)
                  (** We know that e' is sc-minimal in Ex0 U es0, and that sc e'0 e'
                        hence since x \in Ex0 U es0 there is a cycle in sc *)
                  exfalso.
                  destruct Hmin as [_ Hmin].
                  eapply Hmin.
                  exists x.
                  split.
                  * destruct HIn;
                      now eauto with Ensembles_DB.
                  * eapply trans;
                      now eauto.
                + (** Case sc e'0 x, that's our goal, hence trivial *)
                  now trivial.
              - intros x HIn Hcontra.
                eapply In_Union_inv in HIn.
                destruct HIn as [HIn | HIn].
                + (** If x \in Ex0 then by hypothesis Hpo2 *)
                  eapply Hpo2;
                    now eauto.
                + (** Otherwise if x \in es0, then by Hpo *)
                  eapply Hpo;
                    now eauto.
            }
            destruct Hcommut as (tp00 & Hstep00 & Hstep00').
            exists (Empty_set _), (Union _ Ex0 es0), tp1, tp00, 0, (S l).
            repeat (split; eauto with Ensembles_DB);
              try (rewrite Union_empty_set_id).
            apply same_set_eq;
              now eauto with Ensembles_DB.
            constructor.
            econstructor;
              now eauto.
          * (** Case sc e' e *)
            assert (HeqUnion: Union _ (Union _ Ex0 es0) es = Union _ (Union _ Ex0 es) es0).
            {
              apply same_set_eq.
              setoid_rewrite <- Union_assoc.
              eauto with Ensembles_DB.
            }
            exists es0, Ex0, tp0, tp0', 1, l.
            repeat (split; eauto with Ensembles_DB).
            rewrite Union_empty_set_id.
            now reflexivity.
            rewrite HeqUnion.
            eapply StepN with (x2 := tp0) (y2 := Union _ Ex0 es); eauto using Step0.
            econstructor; eauto.
            (** e' is sc-minimal *)
            split.
            right.
            eapply Henum0; simpl; now auto.
            intros (y & HIny & Hscy).
            apply In_Union_inv in HIny.
            destruct HIny as [HIny | HIny].
            eapply In_Union_inv in HIny.
            destruct HIny as [HIny | HIny].
            destruct Hmin as [_ Hcontra].
            eapply Hcontra.
            exists y. split; eauto with Ensembles_DB.
            eapply Henum in HIny.
            simpl in HIny. destruct HIny as [? | HIny]; subst.
            eapply antisym in Hscy; eauto.
            eapply enumerate_spec with (R := po) (es'0 := nil) in HIny;
              eauto with Po_db Relations_db.
            apply Hincl in HIny.
            assert (sc e e') by (eapply trans; eauto).
            eapply Hneq.
            eapply antisym; eauto.
            (** by enumeration e' is po and sc minimal in es0 *)
            eapply Henum0 in HIny.
            simpl in HIny.
            destruct HIny as [? | HIny];
              [ subst; eapply strict; eauto|].
            eapply @enumerate_spec with (R := po) (es' := nil) in HIny;
              eauto with Relations_db  Po_db.
            apply Hincl in HIny.
            eapply (strict sc ltac:(auto) y); 
              pose proof (antisym _ HscPO _ _ Hscy HIny);
              subst; eauto.
            rewrite Union_empty_set_id in Hfresh.
            pose proof (Disjoint_Union_l _ _ _ Hfresh).
            pose proof (Disjoint_Union_r _ _ _ Hfresh).
            now eauto with Ensembles_DB.
        + (** Case k > 0 *)
          inv HRstep.                               
          exists (Union _ Ex0' es0), Ex0, tp0, tp0', (S (S k)), l.
          repeat (apply conj; eauto).
          (** Union equality *)
          apply same_set_eq.
          rewrite Union_assoc.
          now auto.
          (** Ex0 is Disjoint from Ex0' U es0 *)
          pose proof (Disjoint_Union_l _ _ _ Hdis).
          pose proof (Disjoint_Union_r _ _ _ Hdis).
          now eauto with Ensembles_DB.
          econstructor; eauto.
          assert (HeqUnion: Union _ (Union _ Ex0 (Union _ Ex0' es0)) es = Union _ (Union _ (Union _ Ex0 Ex0') es) es0)
            by (apply same_set_eq;
                setoid_rewrite <- Union_assoc;
                eauto with Ensembles_DB).
          rewrite HeqUnion.
          econstructor; eauto.
          (** e' is sc-minimal*)
          (** Obviously e is not sc-minimal in Ex0 U Ex0' U es by [stepN_inv_not_minimal] *)
          eapply stepN_inv_not_minimal in HRstepK; eauto.
          constructor.
          right.
          eapply Henum0;
            simpl; now auto.
          rewrite <- HeqUnion.
          intros (? & HIn & Hscy).
          apply In_Union_inv in HIn.
          destruct HIn as [HIn | HIn].
          (** Case x is in Ex0 U Ex0' U es0, by Hmin we know e' is sc-minimal in this set *)
          eapply Hmin.
          exists x.
          setoid_rewrite <- Union_assoc.
          split;
            now eauto with Ensembles_DB.
          (** Case x is es, then by enumerate_spec it must be that sc e x and we know that x is not minimal
                in the set Ex0 U Ex0' U es, hence there must be some sc-before element in Ex0 U Ex0'. But
             e' is minimal in Ex0 U Ex0' U es0, hence by transitivity it's minimal in Ex0 U Ex0' U es as well*)
          assert (Hnotmin: exists e'', e'' \in (Union _ Ex0 Ex0') /\ sc e'' e).
          { assert (Hclassic: (exists e'' : id, In id (Union id Ex0 Ex0') e'' /\ sc e'' e) \/
                              ~ ( exists e'' : id, In id (Union id Ex0 Ex0') e'' /\ sc e'' e)) by (now apply EM).
            destruct Hclassic as [? | Hcontra]; auto.
            exfalso.
            eapply HRstepK.
            constructor.
            right. eapply Henum; simpl; now auto.
            intros (z & HInz & Hscz).
            apply In_Union_inv in HInz.
            destruct HInz as [? | HInz]; [now eauto|].
            apply Henum in HInz; simpl in HInz;
              destruct HInz as [? | HInz]; subst.
            eapply strict; now eauto.
            eapply enumerate_hd with (R := po) in HInz; eauto with Relations_db Po_db.
            apply Hincl in HInz.
            pose proof (antisym _ ltac:(eauto) _ _ Hscz HInz); subst.
            eapply strict;
              now eauto.
          }
          destruct Hnotmin as (e'' & HIne'' & Hsc'').
          assert (Hsc_trans: sc e'' e').
          { eapply Henum in HIn. simpl in HIn.
            destruct HIn as [? | HIn]; subst.
            eapply trans;
              now eauto with Relations_db.
            eapply enumerate_hd with (R := po) in HIn;
              eauto with Relations_db Po_db.
            apply Hincl in HIn.
            eapply trans; eauto.
            eapply trans;
              now eauto.
          }
          eapply Hmin.
          exists e''.
          split;
            now auto.
          pose proof (Disjoint_Union_r _ _ _ Hfresh).
          now eauto with Ensembles_DB.
    Qed.

    
    Lemma step_po_sim:
      forall n Ex tp1 Ex1 tp2 Ex2 tp1' Ex1'
        (Hsim: sim n Ex tp1 Ex1 tp2 Ex2)
        (Hstep_po: [tp1, Ex1] ==>po [tp1', Ex1']),
      exists Ex2',
        sim (S n) Ex tp1' Ex1' tp2 Ex2'.
    Proof.
      intros.
      inversion Hstep_po.
      destruct Hsim; subst.
      pose proof (Disjoint_Union_r _ _ _ set_dis0) as Hdis2.
      apply Disjoint_sym in Hdis2.
      assert (Hpo: forall e'0, In _ Ex2 e'0 -> ~po e' e'0).
      { intros e'0 HIn.
        eapply ex_po0; eauto.
        right.
        apply (proj1 Henum);
          simpl; now auto.
      }
      assert (Hsc_tot: forall e1 e2 : id,
                 e1 <> e2 ->
                 In id (Union id Ex2 es) e1 /\ In id (Union id Ex2 es) e2 ->
                 sc e1 e2 \/ sc e2 e1).
      { intros e1 e2 Hneq (HIn1 & HIn2).
        eapply sc_tot0; eauto.
        setoid_rewrite set_inv0.
        split;
        setoid_rewrite <- Union_assoc;
        right;
        setoid_rewrite Union_commut;
        now eauto with Ensembles_DB.
      }
      (** By [steps_sc_split_at] we can split the execution of [tp2,Ex2] while interleaving
          an sc-step [tp1, es] ==> [tp1', _] *)
      destruct (steps_sc_split_at _ _ _ _ _ _ _ _ sc_steps0 po_sc0 Hstep Henum
                                  Hdis2 Hpo po_wf0 (PO _ _ sc_tot0) Hsc_tot)
        as (Ex2' & Ex2''  & tp0 & tp0' & k & l & Heq_Ex2 & Hdis2' & HRstepK & HRstep & HRstepL & Hn).
      (** So we re-establish the simulation relation with [tp1',Ex1'] and [tp2, Ex2 Union es] *)
      exists (Union _ Ex2 es).
      constructor; eauto with Ensembles_DB.
      - (** Invariant on Ex, Ex1, Ex2 *)
        setoid_rewrite Union_commut with (s2 := es).
        setoid_rewrite Union_assoc.
        now auto.
      - (** tp2 steps to tp1 *)
        assert (HRstepSL: [tp0, Union _ Ex2'' es] ==>{S l} [tp1', Empty_set _])
          by (econstructor; now eauto).

        Lemma stepN_trans:
          forall {A B : Type} {R: A -> B -> A -> B -> Prop} k l m x y x' y' x'' y''
            (Hm: m = k + l)
            (HstepK: stepN R k x y x' y')
            (HstepL: stepN R l x' y' x'' y''),
            stepN R m x y x'' y''.
        Proof.
          intros A B R k.
          induction k; intros.
          - inv HstepK.
            simpl.
            now auto.
          - inv HstepK.
            econstructor;
              now eauto.
        Qed.
        rewrite <- Heq_Ex2 in HRstepK.
        eapply @stepN_trans with (m := S n) (k := k) (l := S l) (x' := tp0);
          eauto.
        rewrite Hn.
        now rewrite add_succ_r.
      - (** Ex2 is the history of the execution: events in Ex1 cannot be po-before events in Ex2*)
        intros e2 HIn2 e1 HIn1.
        apply In_Union_inv in HIn2.
        destruct HIn2 as [HIn2 | HIn2].
        + (** If e2 is in Ex2 then by simulation relation *)
          eapply ex_po0;
            now eauto.
        + (** If e2 is in es *)
          assert (Hpo2: po e' e2) by admit.
          intros Hcontra.
          eapply Hmin.
          exists 



         

      


    (* Goal *)
    Theorem axiomaticToIntermediate:
      forall n tp tp' Ex
        (Hexec: Rsteps cstep genv po po n (tp, Ex) (tp', Empty_set _))
        (Hvalid: validSC Ex po sc),
        Rsteps cstep genv po sc n (tp, Ex) (tp', Empty_set _).
    Proof.
      Admitted.

  
