(** * Relating axiomatic SC semantics to the Erased machine (operational SC) *)

Require Import concurrency.Machine_ax.
Require Import concurrency.Executions_ax.
Require Import Coq.Sets.Ensembles.
Require Import Coq.Relations.Relations.
Require Import concurrency.Ensembles_util.


(** This proof is done in two steps:
    1. Valid SC executions ([validSC]) generated by the axiomatic semantics
       [step_po] are related to valid SC executions generated by an intermediate
       axiomatic semantics that follow the [sc] order instead.
    2. The intermediate axiomatic semantics are related to the operational
       SC semantics. *)

(** * Part 1 *)
Module AxiomaticIntermediate.

  Import Execution.
  Import ValidSC.
  
  Section AxiomaticIntermediate.
    Context
      {lbl : Labels}
      {sem : Semantics E}
      {threadpool : ThreadPool C}
      {genv : G}
      {exec : Execution E}
      {po sc : relation id}.

    Variable cstep: G -> t -> tid -> list E -> t -> Prop.

    Notation " '[' tp1 , Ex1 ']'   '==>{' n  '}'  '[' tp2 , Ex2 ']' " :=
      (stepN (Rstep cstep genv po sc) n tp1 Ex1 tp2 Ex2) (at level 40).

    Notation " '[' tp1 , Ex1 ']'  '==>po' '[' tp2 , Ex2 ']' " :=
      (step_po cstep genv po tp1 Ex1 tp2 Ex2) (at level 40).

    Notation " '[' tp1 , Ex1 ']'  '==>sc' '[' tp2 , Ex2 ']' " :=
      (Rstep cstep genv po sc tp1 Ex1 tp2 Ex2) (at level 40).

    Notation "tp1 '[' i , ls ']==>' tp2" :=
      (AxSem.step cstep genv tp1 i ls tp2) (at level 40).
    
    Record sim (n:nat) (Ex : events) (tp1 : t) (Ex1 : events) (tp2 : t) (Ex2 : events) :=
      { set_dis  : Disjoint _ Ex1 Ex2;
        set_inv  : Ex <--> Union _ Ex1 Ex2;
        sc_steps : [tp2, Ex2] ==>{n} [tp1, Empty_set _];
        ex_po    : forall e2, e2 \in Ex2 ->
                               forall e1, e1 \in Ex1 ->
                                            ~ po e1 e2;
        sc_tot   : strict_total_order sc Ex;
        po_sc    : inclusion _ po sc
      }.

    Lemma commute_sc:
      forall n tp Ex es e' es' tp' Ex' tp''
        (Hsc_steps: [tp, Ex] ==>{n} [tp', Ex'])
        (Hp_step: tp' [thread e', List.map lab (e' :: es')]==> tp'')
        (Henum: enumerate po es (e' :: es'))
        (Hmin: e' \in min sc (Union _ Ex es))
        (Hincl: inclusion id po sc)
        (Hdis: Disjoint _ Ex es),
        [tp, Union _ Ex es] ==>{S n} [tp'', Ex'].
    Proof.
      intro n.
      induction n; intros.
      - (** Base case *)
        inv Hsc_steps.
        eapply StepN with (x1 := tp') (y1 := Union _ Ex' es)
                                      (x2 := tp'') (y2 := Ex');
          simpl.
        eapply @RStep; eauto.
        now constructor.
      - (** Inductive case *)
        inversion Hsc_steps as [|? ? ? tp0 Ex0 ? ?]; subst.
        assert (e' \in (min sc (Union _ Ex0 es)))
          by admit.
        assert (Disjoint _ Ex0 es)
          by admit.
        specialize (IHn _ _ _ _ _ _ _ _ HRstepN' Hp_step Henum H Hincl H0).
        


        specialize (IHn _ 
                        
        econstructor.
        
    Lemma step_po_sim:
      forall n Ex tp1 Ex1 tp2 Ex2 tp1' Ex1'
        (Hsim: sim n Ex tp1 Ex1 tp2 Ex2)
        (Hstep_po: (tp1, Ex1) ==>po (tp1', Ex1')),
      exists G2',
        sim n Ex tp1' Ex1' tp2 G2'.
    Proof.
      intros.
      assert (HstepsSC := steps _ _ _ _ _ _ Hsim).
      inv Hstep_po.


      Lemma steps_sc_split_at:
        forall n tp1 Ex1 tp2 Ex2 e
          (Hsteps_sc: (tp1, Ex1) ==>{n} (tp2, Ex2))
....          


      


    (* Goal *)
    Theorem axiomaticToIntermediate:
      forall n tp tp' Ex
        (Hexec: Rsteps cstep genv po po n (tp, Ex) (tp', Empty_set _))
        (Hvalid: validSC Ex po sc),
        Rsteps cstep genv po sc n (tp, Ex) (tp', Empty_set _).
    Proof.
      Admitted.

  
